<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>舞台配置エディタ</title>

<style>
body{
  margin:0;
  display:flex;
  height:100vh;
  font-family:sans-serif;
}

#toolbar{
  width:240px;
  background:#f2f2f2;
  padding:10px;
  border-right:2px solid #ccc;
}

.paletteItem{
  background:white;
  border:1px solid #999;
  padding:6px;
  margin:4px 0;
  cursor:grab;
}

canvas{
  flex:1;
  background:white;
  touch-action:none;
}
</style>
</head>

<body>

<div id="toolbar">
<h3>パレット</h3>

<div class="paletteItem" draggable="true" data-type="chair">椅子</div>
<div class="paletteItem" draggable="true" data-type="stand">譜面台</div>
<div class="paletteItem" draggable="true" data-type="step">段</div>
<div class="paletteItem" draggable="true" data-type="spot">スポット照明</div>

</div>

<canvas id="stage"></canvas>

<script>
const canvas=document.getElementById("stage");
const ctx=canvas.getContext("2d");

function resize(){
  canvas.width=window.innerWidth-240;
  canvas.height=window.innerHeight;
}
resize();
window.onresize=resize;

const items=[];
let selectedItems=[];

let dragging=false;
let resizing=null;

/* 範囲選択 */
let selecting=false;
let selectionBox=null;

let startX=0,startY=0;

/* ======================
   パレットD&D
====================== */

document.querySelectorAll(".paletteItem").forEach(el=>{
  el.addEventListener("dragstart",e=>{
    e.dataTransfer.setData("type",el.dataset.type);
  });
});

canvas.addEventListener("dragover",e=>e.preventDefault());

canvas.addEventListener("drop",e=>{
  e.preventDefault();
  const rect=canvas.getBoundingClientRect();

  const type=e.dataTransfer.getData("type");

  items.push({
    type,
    x:e.clientX-rect.left,
    y:e.clientY-rect.top,
    w:120,
    h:60,
    resizable:(type==="step"||type==="spot")
  });

  draw();
});

/* ======================
   共通座標取得
====================== */

function getPos(e){
  const rect=canvas.getBoundingClientRect();
  if(e.touches){
    return {
      x:e.touches[0].clientX-rect.left,
      y:e.touches[0].clientY-rect.top
    };
  }
  return {
    x:e.clientX-rect.left,
    y:e.clientY-rect.top
  };
}

/* ======================
   DOWN
====================== */

function pointerDown(e){

  const p=getPos(e);
  startX=p.x;
  startY=p.y;

  let clicked=null;

  for(let i=items.length-1;i>=0;i--){
    const o=items[i];

    if(o.resizable){
      if(p.x>o.x+o.w-10 &&
         p.x<o.x+o.w &&
         p.y>o.y+o.h-10 &&
         p.y<o.y+o.h){
        resizing=o;
        return;
      }
    }

    if(p.x>o.x && p.x<o.x+o.w &&
       p.y>o.y && p.y<o.y+o.h){
      clicked=o;
      break;
    }
  }

  if(clicked){
    selectedItems=[clicked];
    dragging=true;
  }else{
    selecting=true;
    selectionBox={x:p.x,y:p.y,w:0,h:0};
    selectedItems=[];
  }

  draw();
}

/* ======================
   MOVE
====================== */

function pointerMove(e){

  const p=getPos(e);

  if(resizing){
    resizing.w=Math.max(30,p.x-resizing.x);
    resizing.h=Math.max(30,p.y-resizing.y);
    draw();
    return;
  }

  if(dragging){
    const dx=p.x-startX;
    const dy=p.y-startY;

    selectedItems.forEach(o=>{
      o.x+=dx;
      o.y+=dy;
    });

    startX=p.x;
    startY=p.y;
    draw();
    return;
  }

  if(selecting){
    selectionBox.w=p.x-selectionBox.x;
    selectionBox.h=p.y-selectionBox.y;
    draw();
  }
}

/* ======================
   UP
====================== */

function pointerUp(){

  dragging=false;
  resizing=null;

  if(selecting){

    const box=normalize(selectionBox);

    selectedItems=items.filter(o=>
      o.x>box.x &&
      o.y>box.y &&
      o.x+o.w<box.x+box.w &&
      o.y+o.h<box.y+box.h
    );

    selecting=false;
    selectionBox=null;
  }

  draw();
}

canvas.addEventListener("mousedown",pointerDown);
canvas.addEventListener("mousemove",pointerMove);
canvas.addEventListener("mouseup",pointerUp);

canvas.addEventListener("touchstart",pointerDown);
canvas.addEventListener("touchmove",pointerMove);
canvas.addEventListener("touchend",pointerUp);

/* ======================
   補助
====================== */

function normalize(b){
  return {
    x:Math.min(b.x,b.x+b.w),
    y:Math.min(b.y,b.y+b.h),
    w:Math.abs(b.w),
    h:Math.abs(b.h)
  };
}

/* ======================
   描画
====================== */

function draw(){

  ctx.clearRect(0,0,canvas.width,canvas.height);

  items.forEach(o=>{

    if(o.type==="chair"){
      ctx.beginPath();
      ctx.arc(o.x+20,o.y+20,20,0,Math.PI*2);
      ctx.stroke();
    }

    if(o.type==="stand"){
      ctx.beginPath();
      ctx.moveTo(o.x+40,o.y);
      ctx.lineTo(o.x+40,o.y+40);
      ctx.moveTo(o.x+20,o.y);
      ctx.lineTo(o.x+60,o.y);
      ctx.stroke();
    }

    if(o.type==="step"){
      ctx.strokeRect(o.x,o.y,o.w,o.h);
    }

    /* ⭐ スポット照明 */
    if(o.type==="spot"){
      ctx.fillStyle="rgba(255,220,0,0.35)";
      ctx.beginPath();
      ctx.arc(o.x+o.w/2,o.y+o.h/2,o.w/2,0,Math.PI*2);
      ctx.fill();
      ctx.strokeStyle="orange";
      ctx.stroke();
      ctx.strokeStyle="black";
    }

    if(selectedItems.includes(o)){
      ctx.strokeStyle="blue";
      ctx.strokeRect(o.x-4,o.y-4,o.w+8,o.h+8);
      ctx.strokeStyle="black";
    }

    if(o.resizable){
      ctx.fillRect(o.x+o.w-8,o.y+o.h-8,8,8);
    }
  });

  /* 範囲選択表示 */
  if(selectionBox){
    const b=normalize(selectionBox);
    ctx.strokeStyle="rgba(0,120,255,0.8)";
    ctx.setLineDash([6]);
    ctx.strokeRect(b.x,b.y,b.w,b.h);
    ctx.setLineDash([]);
  }
}

draw();
</script>
</body>
</html>
